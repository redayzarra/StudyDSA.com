export const arraySkills: { title: string; href: string; description: string }[] = [
  {
    title: "Definition",
    href: "/",
    description: "You just store stuff in a line, it's quite literally a list of stuff",
  },
  {
    title: "Operations",
    href: "/",
    description: "Here's everything you can do with arrays and their complexities",
  },
  {
    title: "Pointers",
    href: "/",
    description: "They point to stuff instead of storing data",
  },
  {
    title: "Static Arrays",
    href: "/",
    description: "They're like a metal can, they can only fit a certain amount",
  },
  {
    title: "Dynamic Arrays",
    href: "/",
    description: "They're basically balloons, you can keep adding to them with no worries",
  },
  {
    title: "Stacks",
    href: "/",
    description: "LIFO - meaning you can quickly access the most recent one",
  },
  {
    title: "Algorithms",
    href: "/",
    description: "These are common algorithms you need to know for arrays and stacks",
  },
  {
    title: "Best Practices",
    href: "/",
    description: "The most efficient way of using arrays and avoiding pitfalls",
  },
]

export const linkedSkills: { title: string; href: string; description: string }[] = [
  {
    title: "Definition",
    href: "/",
    description: "It's like that Spider-Man meme where they are all pointing to each other",
  },
  {
    title: "Operations",
    href: "/",
    description: "Here's everything you can do with linked lists and their complexities",
  },
  {
    title: "Implementation",
    href: "/",
    description: "You implement a linked list with a 'Node' class that has pointers and values",
  },
  {
    title: "Pointers",
    href: "/",
    description: "Nodes have pointers which point to the previous or next node",
  },
  {
    title: "Singly Linked List",
    href: "/",
    description: "Think of a treasure hunt, each clue leads to the next until the end",
  },
  {
    title: "Doubly Linked List",
    href: "/",
    description: "Think of this as a two-way street, you can go to previous or next node",
  },
  {
    title: "Algorithms",
    href: "/",
    description: "These are common algorithms you need to know for linked lists",
  },
  {
    title: "Best Practices",
    href: "/",
    description: "The most efficient way of using linked lists and avoiding pitfalls",
  },
]

export const hashmapSkills: { title: string; href: string; description: string }[] = [
  {
    title: "Definition",
    href: "/",
    description: "Hashmaps store unique key-value pairs and sets hate duplicates",
  },
  {
    title: "Operations",
    href: "/",
    description: "Here's everything you can do with hashmap and sets",
  },
  {
    title: "Implementation",
    href: "/",
    description: "They're like a metal can, they can only fit a certain amount",
  },
  {
    title: "Hash Function",
    href: "/",
    description: "Just converts input into something unique",
  },
  {
    title: "Chaining",
    href: "/",
    description: "They're basically balloons, you can keep adding to them",
  },
  {
    title: "Sets",
    href: "/",
    description: "They hate duplicates and searching in them is really efficient",
  },
  {
    title: "Algorithms",
    href: "/",
    description: "These are all the common algorithms for hashmaps and sets",
  },
  {
    title: "Best Practices",
    href: "/",
    description: "The best way to use hashmaps and sets for efficiency",
  },
]

export const queueSkills: { title: string; href: string; description: string }[] = [
  {
    title: "Definition",
    href: "/",
    description: "FIFO - meaning it's first come, first served",
  },
  {
    title: "Operations",
    href: "/",
    description: "Here's everything you can do with queues",
  },
  {
    title: "Implementation",
    href: "/",
    description: "Think of a line at the bank, the earliest one goes first",
  },
  {
    title: "Circular Queue",
    href: "/",
    description: "Efficiently uses space by connecting the last positition back to the first",
  },
  {
    title: "Priority Queue",
    href: "/",
    description: "Each element has a priority meaning you can access elements based on that",
  },
  {
    title: "Deque",
    href: "/",
    description: "Double-ended meaning you can insert and delete at the front and the rear",
  },
  {
    title: "Algorithms",
    href: "/",
    description: "These are all the common algorithms for queues",
  },
  {
    title: "Best Practices",
    href: "/",
    description: "This is the best way to use queues for best time and memory complexity",
  },
]
