export const arraySkills: { title: string; href: string; description: string }[] = [
  {
    title: "Definition",
    href: "/",
    description: "You just store stuff in a line, it's quite literally a list of stuff",
  },
  {
    title: "Operations",
    href: "/",
    description: "Here's everything you can do with arrays and their complexities",
  },
  {
    title: "Pointers",
    href: "/",
    description: "They point to stuff instead of storing data",
  },
  {
    title: "Static Arrays",
    href: "/",
    description: "They're like a metal can, they can only fit a certain amount",
  },
  {
    title: "Dynamic Arrays",
    href: "/",
    description: "They're basically balloons, you can keep adding to them with no worries",
  },
  {
    title: "Stacks",
    href: "/",
    description: "LIFO - meaning you can quickly access the most recent one",
  },
  {
    title: "Algorithms",
    href: "/",
    description: "These are common algorithms you need to know for arrays and stacks",
  },
  {
    title: "Best Practices",
    href: "/",
    description: "The most efficient way of using arrays and avoiding pitfalls",
  },
]

export const linkedSkills: { title: string; href: string; description: string }[] = [
  {
    title: "Definition",
    href: "/",
    description: "It's like that Spider-Man meme where they are all pointing to each other",
  },
  {
    title: "Operations",
    href: "/",
    description: "Here's everything you can do with linked lists and their complexities",
  },
  {
    title: "Implementation",
    href: "/",
    description: "You implement a linked list with a 'Node' class that has pointers and values",
  },
  {
    title: "Pointers",
    href: "/",
    description: "Nodes have pointers which point to the previous or next node",
  },
  {
    title: "Singly Linked List",
    href: "/",
    description: "Think of a treasure hunt, each clue leads to the next until the end",
  },
  {
    title: "Doubly Linked List",
    href: "/",
    description: "Think of this as a two-way street, you can go to previous or next node",
  },
  {
    title: "Algorithms",
    href: "/",
    description: "These are common algorithms you need to know for linked lists",
  },
  {
    title: "Best Practices",
    href: "/",
    description: "The most efficient way of using linked lists and avoiding pitfalls",
  },
]

export const hashmapSkills: { title: string; href: string; description: string }[] = [
  {
    title: "Definition",
    href: "/",
    description: "Hashmaps store unique key-value pairs and sets hate duplicates",
  },
  {
    title: "Operations",
    href: "/",
    description: "Here's everything you can do with hashmap and sets",
  },
  {
    title: "Implementation",
    href: "/",
    description: "They're like a metal can, they can only fit a certain amount",
  },
  {
    title: "Hash Function",
    href: "/",
    description: "Just converts input into something unique",
  },
  {
    title: "Chaining",
    href: "/",
    description: "They're basically balloons, you can keep adding to them",
  },
  {
    title: "Sets",
    href: "/",
    description: "They hate duplicates and searching in them is really efficient",
  },
  {
    title: "Algorithms",
    href: "/",
    description: "These are all the common algorithms for hashmaps and sets",
  },
  {
    title: "Best Practices",
    href: "/",
    description: "The best way to use hashmaps and sets for efficiency",
  },
]

export const queueSkills: { title: string; href: string; description: string }[] = [
  {
    title: "Definition",
    href: "/",
    description: "FIFO - meaning it's first come, first served",
  },
  {
    title: "Operations",
    href: "/",
    description: "Here's everything you can do with queues",
  },
  {
    title: "Implementation",
    href: "/",
    description: "Think of a line at the bank, the earliest one goes first",
  },
  {
    title: "Circular Queue",
    href: "/",
    description: "Efficiently uses space by connecting the last positition back to the first",
  },
  {
    title: "Priority Queue",
    href: "/",
    description: "Each element has a priority meaning you can access elements based on that",
  },
  {
    title: "Deque",
    href: "/",
    description: "Double-ended meaning you can insert and delete at the front and the rear",
  },
  {
    title: "Algorithms",
    href: "/",
    description: "These are all the common algorithms for queues",
  },
  {
    title: "Best Practices",
    href: "/",
    description: "This is the best way to use queues for best time and memory complexity",
  },
]

export const treeSkills: { title: string; href: string; description: string }[] = [
  {
    title: "Definition",
    href: "/",
    description: "FIFO - meaning it's first come, first served",
  },
  {
    title: "Operations",
    href: "/",
    description: "Here's everything you can do with queues",
  },
  {
    title: "Implementation",
    href: "/",
    description: "Think of a line at the bank, the earliest one goes first",
  },
  {
    title: "Circular Queue",
    href: "/",
    description: "Efficiently uses space by connecting the last positition back to the first",
  },
  {
    title: "Priority Queue",
    href: "/",
    description: "Each element has a priority meaning you can access elements based on that",
  },
  {
    title: "Deque",
    href: "/",
    description: "Double-ended meaning you can insert and delete at the front and the rear",
  },
  {
    title: "Algorithms",
    href: "/",
    description: "These are all the common algorithms for queues",
  },
  {
    title: "Best Practices",
    href: "/",
    description: "This is the best way to use queues for best time and memory complexity",
  },
]

export const graphSkills: { title: string; href: string; description: string }[] = [
  {
    title: "Definition",
    href: "/",
    description: "Graphs consist on nodes that are connected to each other with edges",
  },
  {
    title: "Operations",
    href: "/",
    description: "Here's everything you can do with graphs based on the representation",
  },
  {
    title: "Implementation",
    href: "/",
    description: "There are many ways to represent graphs based on the problem",
  },
  {
    title: "Matrix",
    href: "/",
    description: "Usually represented by arrays, they basically form a rectangle of nodes",
  },
  {
    title: "Adjacency Matrix",
    href: "/",
    description: "A matrix that always forms a square and shows relationships",
  },
  {
    title: "Adjacency List",
    href: "/",
    description: "Each node has a list of it's neighbors, most common representation",
  },
  {
    title: "Algorithms",
    href: "/",
    description: "These are all the common algorithms for graphs that you need to know",
  },
  {
    title: "Best Practices",
    href: "/",
    description: "This is the best way to use graphs based on their representations",
  },
]

export const heapSkills: { title: string; href: string; description: string }[] = [
  {
    title: "Definition",
    href: "/",
    description: "They are basically binary trees with a specific order and structure",
  },
  {
    title: "Operations",
    href: "/",
    description: "Here's everything you can do with heaps",
  },
  {
    title: "Implementation",
    href: "/",
    description: "Heaps have to maintain their order and structure even if they change",
  },
  {
    title: "Order & Structure",
    href: "/",
    description: "Looking under the hood of how heaps maintain their order and structure",
  },
  {
    title: "Heapify",
    href: "/",
    description: "This is how an unordered array of numbers turns into a ordered heap",
  },
  {
    title: "Min/Max Heap",
    href: "/",
    description: "Here's how you can use min and max heaps most efficiently",
  },
  {
    title: "Algorithms",
    href: "/",
    description: "These are all the common algorithms for heaps that you need to know",
  },
  {
    title: "Best Practices",
    href: "/",
    description: "This is the best way to use heaps for best time and space complexity",
  },
]

export const trieSkills: { title: string; href: string; description: string }[] = [
  {
    title: "Definition",
    href: "/",
    description: "They are known as prefix trees because they form words & prefixes",
  },
  {
    title: "Operations",
    href: "/",
    description: "Here's everything you can do with tries",
  },
  {
    title: "Implementation",
    href: "/",
    description: "Each node in the trie must store the children and if the word is reached",
  },
  {
    title: "Insertion",
    href: "/",
    description: "To insert into a trie we essentially follow the letters and add to the gaps",
  },
  {
    title: "Searching",
    href: "/",
    description: "You can find words by simply following the letters and checking if it's marked",
  },
  {
    title: "Finding Prefixes",
    href: "/",
    description: "You can follow the letters as long as they satisfy the prefix",
  },
  {
    title: "Algorithms",
    href: "/",
    description: "These are all the common algorithms for tries or prefix trees",
  },
  {
    title: "Best Practices",
    href: "/",
    description: "This is the most efficient way of using tries",
  },
]